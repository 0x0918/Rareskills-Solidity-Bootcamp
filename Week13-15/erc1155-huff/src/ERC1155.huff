/* Interface */

//// READ ERC1155 STANDARD FUNCTIONS
#define function balanceOf(address,uint256) view returns (uint256)
#define function balanceOfBatch(address[],uint256[]) view returns (uint256[])
#define function isApprovedForAll(address,address) view returns (bool)

//// WRITE ERC1155 STANDARD FUNCTIONS
#define function setApprovalForAll(address,bool) nonpayable returns()
#define function safeTransferFrom(address,address,uint256,uint256,bytes) nonpayable returns()
#define function safeBatchTransferFrom(address,address,uint256[],uint256[],bytes) nonpayable returns()
#define function batchMint(address,uint256[],uint256[]) nonpayable returns()
//#define function batchMint(address to, uint256[] calldata id, uint256[] calldata amounts, bytes calldata) external

//// NON-STANDARD FUNCTIONS
#define function mint(address,uint256,uint256,bytes) nonpayable returns()
//#define function mint(address to, uint256 id, uint256 amount, bytes calldata) external

/*
#######################################
#                                     #
#                 MAIN                #
#                                     #
#######################################
*/
#define macro MAIN() = takes (0) returns (0) {
    // Identify which function is being called.
    0x00 calldataload 0xe0 shr
    // WRITE FUNCTIONS FIRST
    /*dup1 __FUNC_SIG(setApprovalForAll) eq setApprovalForAll jumpi
    dup1 __FUNC_SIG(safeTransferFrom) eq safeTransferFrom jumpi
    dup1 __FUNC_SIG(safeBatchTransferFrom) eq safeBatchTransferFrom jumpi
    dup1 __FUNC_SIG(batchMint) eq batchMint jumpi*/
    dup1 __FUNC_SIG(mint) eq mint jumpi


    // READ FUNCTIONS
    dup1 __FUNC_SIG(balanceOf) eq balanceOf jumpi
    /*dup1 __FUNC_SIG(balanceOfBatch) eq balanceOfBatch jumpi
    dup1 __FUNC_SIG(isApprovedForAll) eq isApprovedForAll jumpi*/

    0x00 0x00 return


    // WRITE FUNCTIONS POINTER
    /*setApprovalForAll:
        SET_APPROVAL_FOR_ALL()
    safeTransferFrom:
        SAFE_TRANSFER_FROM()
    safeBatchTransferFrom:
        SAFE_BATCH_TRANSFER_FROM()
    batchMint:
        BATCH_MINT()*/
    mint:
        MINT()


    // READ FUNCTIONS POINTER
    balanceOf:
        BALANCE_OF()
    /*balanceOfBatch:
        BALANCE_OF_BATCH()
    isApprovedForAll:
        IS_APPROVED_FOR_ALL()*/

}

/*
#######################################
#                                     #
#             HELP MACROS             #
#                                     #
#######################################
*/

#define macro CALCULATE_DOUBLE_MAPPING() = takes (3) returns (1) {
    swap2 0x0 mstore // mstore(third arg)
    swap1 0x20 mstore // mstore(first arg), mappingSlot should be == 0
    0x40 0x00 sha3 // sha3, on stack

    swap1 0x0 mstore // mstore(second arg)
    0x20 mstore // mstore(calculated sha3)
    0x40 0x00 sha3 // sha3, on stack (return value)
}


/*
#######################################
#                                     #
#            WRITE METHODS            #
#                                     #
#######################################
*/
/*
#define macro SET_APPROVAL_FOR_ALL() = takes (0) returns (0) {
    0x04 calldataload   // [value]
    [VALUE_LOCATION]    // [ptr, value]
    sstore              // []
}

#define macro SAFE_TRANSFER_FROM() = takes (0) returns (0) {
    0x04 calldataload   // [value]
    [VALUE_LOCATION]    // [ptr, value]
    sstore              // []
}

#define macro SAFE_BATCH_TRANSFER_FROM() = takes (0) returns (0) {
    0x04 calldataload   // [value]
    [VALUE_LOCATION]    // [ptr, value]
    sstore              // []
}

#define macro BATCH_MINT() = takes (0) returns (0) {
    0x04 calldataload   // [value]
    [VALUE_LOCATION]    // [ptr, value]
    sstore              // []
}*/

#define macro MINT() = takes (0) returns (0) {
    0x24 calldataload   // tokenId - third argument
    0x04 calldataload   // address - second argument
    0x00                // balanceOf mapping storage slot - first argument
    
    CALCULATE_DOUBLE_MAPPING() // will return balanceSlot on stack
    0x00 0x00 dup3 log1 // DEBUG
    0x00 0x00 0x12 log1 // DEBUG
    
    dup1 sload          // load balance
    0x00 0x00 dup3 log1 // DEBUG
    0x44 calldataload   // load number to mint
    add                 // add it

    dup1 //DEBUG

    swap2 sstore // store new balance in storage

    0x20 0x00 return // return value
}



/*
#######################################
#                                     #
#            READ METHODS             #
#                                     #
#######################################
*/
/*
#define macro GET_VALUE() = takes (0) returns (0) {
    // Load value from storage.
    [VALUE_LOCATION]   // [ptr]
    sload                // [value]

    // Store value in memory.
    0x00 mstore

    // Return value
    0x20 0x00 return
}*/

// balanceOf(address,uint256)
#define macro BALANCE_OF() = takes (0) returns (0) {
    0x24 calldataload   // tokenId - third argument
    0x04 calldataload   // address - second argument
    0x00                // balanceOf mapping storage slot - first argument
    
    CALCULATE_DOUBLE_MAPPING() // will return balanceSlot on stack

    sload // load balance
    0x00 mstore // store balance on memory

    0x20 0x00 return // return value
}
/*
#define macro BALANCE_OF_BATCH() = takes (3) returns (0) {
    0x04 calldataload   // [value]
    [VALUE_LOCATION]    // [ptr, value]
    sstore              // []
}


#define macro IS_APPROVED_FOR_ALL() = takes (3) returns (0) {
    0x04 calldataload   // [value]
    [VALUE_LOCATION]    // [ptr, value]
    sstore              // []
}
