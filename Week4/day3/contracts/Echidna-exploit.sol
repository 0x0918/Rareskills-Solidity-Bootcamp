pragma solidity ^0.8.0;

//import "./token-sale-modified.sol";
import "./Ethernaut-Dex.sol";

contract ZigturEchidnaDay3 {
    Dex internal dexContract;
    SwappableToken internal token1;
    SwappableToken internal token2;

    event Debug(uint256);
    event Balance1(uint256);
    event Balance2(uint256);


    constructor() payable {
        dexContract = new Dex();
        token1 = new SwappableToken(address(dexContract), "ZigDex1", "ZD1", 110 ether);
        token2 = new SwappableToken(address(dexContract), "ZigDex2", "ZD2", 110 ether);
        dexContract.setTokens(address(token1), address(token2));

        //transfer to dex
        emit Debug(1);
        token1.approve(address(this), address(dexContract), 100 ether);
        token2.approve(address(this), address(dexContract), 100 ether);

        emit Debug(2);
        dexContract.addLiquidity(address(token1), 100 ether);
        dexContract.addLiquidity(address(token2), 100 ether);

        // attacker approve dex
        token1.approve(address(this), address(dexContract), 2**254);
        token2.approve(address(this), address(dexContract), 2**254);

        // renounce ownership
        dexContract.transferOwnership(address(dexContract));

        //token1.transfer(address(this), 10 ether);
        //token2.transfer(msg.sender, 10 ether);
    }

    function attack(uint256 amountOfTokens, bool chooseToken) public {
        uint256 balance1 = token1.balanceOf(address(this));
        emit Balance1(balance1);
        uint256 balance2 = token2.balanceOf(address(this));
        emit Balance2(balance2);
        uint256 balance1Dex = token1.balanceOf(address(dexContract));
        uint256 balance2Dex = token2.balanceOf(address(dexContract));

        if(chooseToken) {
            dexContract.swap(address(token2), address(token1), (amountOfTokens % balance2) % balance2Dex);
        }
        else {
            dexContract.swap(address(token1), address(token2), (amountOfTokens % balance1) % balance1Dex);
        }
        
        assert(token1.balanceOf(address(dexContract)) >= 70 ether);
        assert(token2.balanceOf(address(dexContract)) >= 70 ether);
        
    }

}
